 **requests** **库中** **post** **方法的** **json=** **和** **data=** **参数，在处理请求体格式、编码方式上有本质区别**，正是这种区别导致了之前的 JSON 解析错误和现在的成功。下面用原理 + 对比的方式讲清楚：

### 一、先明确核心：HTTP 请求中「数据格式」和「Content-Type 头」必须匹配

服务器（比如你访问的 QCC 网站）接收请求时，会先看请求头里的 **Content-Type**，再按照这个类型去解析请求体里的数据：

- 如果 Content-Type: application/json（你的代码里已经设置了这个头），服务器就会按 **JSON 格式** 解析请求体；

- 如果解析时发现请求体不是合法 JSON（比如是普通字符串、字典原始格式），就会报 Unexpected token xxx 错误（你之前遇到的就是这个）。

而 requests 的 json= 和 data= 参数，决定了请求体最终会被处理成什么格式，以及是否自动适配 Content-Type。

### 二、data=data 和 json=data 的本质区别（关键）

假设你代码中构造的原始数据是一个 Python 字典 data = {"key": "小米", "page": 2}，我们用表格对比两种参数的差异：

| 对比维度                | data=data（你之前的写法）                                    | json=data（你现在的写法，成功的原因）                        |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **数据类型要求**        | 接收 字典、字符串、字节流 等多种类型                         | 只接收 Python 字典/列表（会自动转 JSON）                     |
| **请求体处理逻辑**      | - 如果传入「字典」：会把字典转成 **表单格式字符串**（比如 key=小米&page=2）；- 如果传入「字符串」：直接把字符串作为请求体发送（不做任何处理）。 | 无论传入什么合法结构（字典 / 列表），都会自动用 json.dumps() 把它转成 **标准 JSON 字符串**（比如 {"key":"小米","page":2}）。 |
| **Content-Type 头适配** | - 如果传入字典：自动添加 Content-Type: application/x-www-form-urlencoded（表单格式）；- 如果传入字符串：**不会自动添加任何 Content-Type**（需要你手动设置）。 | 自动添加 Content-Type: application/json（即使你没手动写这个头，它也会加）。 |
| **服务器解析结果**      | 假设你传入字典 data={"key":...}：请求体是 key=小米&page=2（表单格式），但你手动设置了 Content-Type: application/json → 服务器按 JSON 解析表单字符串，必然失败（因为 key=小米... 不是 JSON）。 | 请求体是 {"key":"小米","page":2}（标准 JSON），且 Content-Type 是 application/json → 服务器按 JSON 解析，完全匹配预期，所以成功。 |

### 三、用你的实际场景还原问题

#### 1. 之前用 data=data 失败的原因

假设你之前的代码是这样的：

```
data = {"key": "小米", "p": 2}  # Python 字典
# 错误写法：用 data=传字典，requests 会转成表单格式
response = session.post(url, data=data, headers=headers)
```

- 此时请求体实际是 **key=小米&p=2**（表单字符串），而不是 JSON；

- 但你的 headers 里设置了 Content-Type: application/json，告诉服务器 “我发的是 JSON”；

- 服务器收到后，按 JSON 格式解析 key=小米&p=2 → 发现开头是 k（不是 {），直接报 Unexpected token k（和你之前的 token s 本质一样，都是格式不匹配）。

#### 2. 现在用 json=data 成功的原因

现在的代码是：

```
data = {"key": "小米", "p": 2}  # 还是同一个 Python 字典
# 正确写法：用 json=传字典，requests 自动处理
response = session.post(url, data=data, headers=headers)
```

- requests 会自动做两件关键的事：

1. 1. 把 Python 字典 data 转成 **标准 JSON 字符串**：{"key":"小米","p":2}（相当于帮你执行了 json.dumps(data)）；

1. 1. 确保 Content-Type 是 application/json（即使你没手动写，它也会加；如果手动写了，会覆盖成正确的）；

- 服务器收到后，Content-Type 是 JSON，请求体也是合法 JSON → 解析成功，返回正常响应。

### 四、延伸：什么时候该用 data=？什么时候用 json=？

根据你要发送的「数据格式」来决定，对应服务器的接收要求：

| 场景                                  | 推荐参数      | 关键注意点                                                   |
| ------------------------------------- | ------------- | ------------------------------------------------------------ |
| 发送 JSON 数据（最常用，如接口请求）  | json=data     | 直接传 Python 字典 / 列表，requests 自动序列化 + 加正确的 Content-Type，无需手动处理。 |
| 发送表单数据（如网页登录、简单提交）  | data=data     | 传 Python 字典，requests 自动转成 key=value&key2=value2 格式，并加 application/x-www-form-urlencoded 头。 |
| 发送原始字符串 / 文件（如自定义格式） | data=原始内容 | 需手动把数据转成字符串 / 字节流，且必须手动设置对应的 Content-Type（比如 text/plain 纯文本、application/xml XML 格式）。 |

### 总结一句话

json=data 是 requests 为「发送 JSON 数据」提供的 **“懒人便捷方式”**，它会自动帮你完成 “字典转 JSON 字符串” 和 “设置 Content-Type 头” 这两个关键步骤，避免手动操作出错；而 data=data 是通用参数，需要你自己保证 “数据格式” 和 “Content-Type” 匹配，否则就会像之前一样触发服务器解析错误。